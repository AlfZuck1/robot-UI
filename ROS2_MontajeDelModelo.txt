#Instalar Ubuntu
#Instalar ROS2 humble
#Instalar librerías
#Crear una carpeta para empaquetar (ros2_ws)
    mkdir -p ~/ros2_ws
    cd ~/ros2_ws
#Crear nuevo paquete:
    ros2 pkg create --build-type ament_python CRSA465

#Si se quiere visualizar el explorador para mover archivos, ejecutar el siguiente comando:
    explorer.exe .

#Dentro de CRSA465 mover todas las carpetas de urdf como se muestra a continuación:
        ros2_ws/
            └── CRSA465/
                ├── launch/
                │   └── display.launch.py
                ├── urdf/
                │   └── CRSA465.urdf
                ├── meshes/
                │   ├── base_link.stl
                │   └── arm_link.stl
                ├── textures/          
                │   └── metal_texture.png
                ├── config/
                │   └── rviz_config.rviz
                ├── package.xml
                └── setup.py (si es tipo Python) o CMakeLists.txt (si es tipo CMake)

#Dentro de Launch crear el archivo display.launch.py

/*display.launch.py*
from launch import LaunchDescription
from launch_ros.actions import Node
import os

from ament_index_python.packages import get_package_share_directory

def generate_launch_description():
    # Obtener la ruta del archivo URDF 
    urdf_path = os.path.join(
        get_package_share_directory('my_robot_description'),
        'urdf',
        'CRSA465.urdf' 
    )

    # Leer el contenido del archivo URDF
    with open(urdf_path, 'r') as infp:
        robot_description_content = infp.read()

    # Crear el nodo de robot_state_publisher y el nodo de joint_state_publisher_gui
    # con el contenido del URDF leído
    return LaunchDescription([
        Node(
            package='robot_state_publisher',
            executable='robot_state_publisher',
            name='robot_state_publisher',
            parameters=[{'robot_description': robot_description_content}],
            output='screen'
        ),
        Node(
            package='joint_state_publisher_gui',
            executable='joint_state_publisher_gui',
            name='joint_state_publisher_gui',
            output='screen'
        )
    ])

#Posteriomente, configurar el setup.py para que reconozca el paquete y las dependencias necesarias:
    from setuptools import setup
    from glob import glob
    import os

    package_name = 'CRSA465'

    setup(
        name=package_name,
        version='0.0.0',
        packages=[package_name],
        data_files=[
            ('share/ament_index/resource_index/packages',
                [f'resource/{package_name}']),
            (os.path.join('share', package_name), glob('package.xml')),
            (os.path.join('share', package_name, 'launch'), glob('launch/*.launch.py')),
            (os.path.join('share', package_name, 'urdf'), glob('urdf/*.urdf')),
            (os.path.join('share', package_name, 'meshes'), glob('meshes/*')),
            (os.path.join('share', package_name, 'textures'), glob('textures/*')),
            (os.path.join('share', package_name, 'config'), glob('config/*'))
        ],
        install_requires=['setuptools'],
        zip_safe=True,
        maintainer='your_name',
        maintainer_email='zuck@todo.todo',
        description='Modelo URDF del robot CRSA465',
        license='MIT',
        tests_require=['pytest'],
        entry_points={
            'console_scripts': [],
        },
    )

#Desde la terminal, dentro de la carpeta ros2_ws, ejecutar los siguientes comandos:
    colcon build
    #La carpeta de instalación se crea dentro de la carpeta ros2_ws
    source install/setup.bash
    #Se ejecuta el launnch para que los nodos de joint_state_publisher_gui y robot_state_publisher se ejecuten
    ros2 launch CRSA465 display.launch.py

#Desde otra terminal, ejecutar el rviz2
    rviz2
    #En la parte izquierda de la ventana, en "Global Options", seleccionar el "Fixed Frame" como "base_link" o la base del robot
    #En la parte izquierda de la ventana, en "Add", seleccionar "RobotModel" y en "Description Source" seleccionar "robot_description"
    #Con esto se debería ver el modelo del robot en RVIZ2

#Para realizar la comunicación entre el robot y el cliente web, se debe instalar el rosbridge en otra terminal y ejecutar el rosbridge
    sudo apt install ros-humble-rosbridge-server
    ros2 launch rosbridge_server rosbridge_websocket_launch.xml



##### Posibles errores
    # Si el robot_state_publisher deja de funcionar una posible causa es la sincronización con el tiempo
    # ¿Qué hacer?
    # En ubuntu:
    sudo apt update
    sudo apt install ntpdate
    sudo timedatectl set-ntp true
    sudo ntpdate ntp.ubuntu.com
    # Sincroinizar tiempo de windows también


### Montar microRos
    sudo apt update
    sudo apt install -y python3-colcon-common-extensions python3-pip
    pip3 install -U colcon-ros-bundle empy setuptools
    sudo apt install ros-humble-micro-ros-agent

    sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key \
    -o /usr/share/keyrings/ros-archive-keyring.gpg

    # Revisar que con "nano /etc/apt/sources.list.d/ros2-latest.list" tenga lo siguiente si es que hay problemas
    deb [arch=amd64 signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu jammy main

    # Clonar el repositorio oficial del agente humble y msgs
    cd ros2_ws/src
    git clone -b humble https://github.com/micro-ROS/micro-ROS-Agent.git
    git clone -b humble https://github.com/micro-ROS/micro_ros_msgs.git

    # Instalar dependencias
    rosdep update
    rosdep install --from-paths src --ignore-src -y
    colcon build
    source install/setup.bash

    # Ejecutar el agente por wifi
    ros2 run micro_ros_agent micro_ros_agent udp4 --port 8888 --dev 0.0.0.0

    # Correr el proxy de python "udp_proxy.py" para redirigir los mensajes.


    ### Esto por ahora no funciona
    # Instalar usbipd para compartir el puerto serial de windows a la máquina virtual
    # Desde powershell:
    winget install usbipd
    Register-ArgumentCompleter -Native -CommandName usbipd -ScriptBlock {
       param($commandName, $wordToComplete, $cursorPosition)
       usbipd [suggest:$cursorPosition] "$wordToComplete" | ForEach-Object {
           [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
       }
    }
    usbipd --help
    usbipd list
    usbipd attach --wsl --busid=<BUSID> (1-2, 1-3)